// This Arduino sketch was automatically generated by IrScrutinizer 2.3.0 using Bomaker Ondine 1 Soundbar.rmdu (http://www.hifi-remote.com/forums/dload.php?action=file&file_id=25809)
#include <Arduino.h>
#include "PinDefinitionsAndMore.h" //required
#include <IRremote.h>
#include <SoftwareSerial.h>

const int IR_CODE_NUM_BITS = 32;
const int soundBarPowerPin = 12;
const int potentiometerPin = A5;
const int backButtonPin = A2;
const int volOvPin = 11;
const int redLedPin = 13;
const int opticalPin = 10;
const int tvPowerPin = 9;
const int scrollPin = 6;
const int blueLedPin = 5;
const int joystickRxPin = A0;
const int joystickRyPin = A1;
const int joystickButtonPin = 2;
const int joystickThreshold = 50;
//https://www.espressif.com/sites/default/files/documentation/4b-esp8266_at_command_examples_en.pdf
const unsigned long keepAliveTimeout = 4999;

//IRsend IrSender;
int soundBarPowerPinState = 0;
int tvPowerPinState = 0;
int volumeValue = 0;
int volumeLevel = 1;
int volumeTracker = 1;
int volOvPinState = 0;
int opticalPinState = 0;
int scrollPinState = 0;
int backButtonPinState = 0;

SoftwareSerial esp8266(8, 7);
String output = "";
String tcpDataInOutput = "";
String tcpDataInSendLength = "";
String joystickOutput = "";
String joystickSendLength = "";
String keepAliveOutput = "";
String keepAliveSendLength = "";
String dataOutResult = "";
String dataInResponse = "";
String dataOutResponse = "";
int xPosition = 0;
int yPosition = 0;
int joystickPinState = 0;
int mapX = 0;
int mapY = 0;
bool soundBarPowerSwitch = false;
bool tvPowerSwitch = false;
bool inputSourceSwitch = false;
bool volumeFirstRead = true;
bool clientConnected = false;
bool esp8266Init = false;
unsigned long timeValue = 0;

void setup() {
  Serial.begin(9600);
#if defined(__AVR_ATmega32U4__) || defined(Serial_USB) || defined(Serial_PORT_USBVIRTUAL)  || defined(ARDUINO_attiny3217)
  delay(4000);
#endif
  Serial.println("Serial ready");

  pinMode(soundBarPowerPin, INPUT_PULLUP);
  pinMode(volOvPin, INPUT_PULLUP);
  pinMode(opticalPin, INPUT_PULLUP);
  pinMode(tvPowerPin, INPUT_PULLUP);
  pinMode(scrollPin, INPUT_PULLUP);
  pinMode(redLedPin, OUTPUT);
  pinMode(blueLedPin, OUTPUT);
  pinMode(joystickRxPin, INPUT);
  pinMode(joystickRyPin, INPUT);
  pinMode(joystickButtonPin, INPUT_PULLUP);
  pinMode(backButtonPin, INPUT_PULLUP);

  IrSender.begin(IR_SEND_PIN, ENABLE_LED_FEEDBACK);
  IrSender.enableIROut(38);
  Serial.println("Infared ready");
  digitalWrite(redLedPin, HIGH);
}

void loop() {
  timeValue = millis();
  while ((timeValue + keepAliveTimeout) > millis()) {
    InnerLoop();
  }
  if (clientConnected) {
    keepAliveOutput = "ka\r\n";
    keepAliveSendLength = "AT+CIPSEND=0," + String(keepAliveOutput.length()) + "\r\n";
    TcpDataOut(keepAliveSendLength, 10);
    TcpDataOut(keepAliveOutput, 100);
    Serial.print("Send keep alive. ");
    Serial.println("timeValue: " + String(timeValue) + " + keepAliveTimeout: " + String(timeValue + keepAliveTimeout));
  } else {
    Serial.print("Keep alive no client. ");
    Serial.println("timeValue: " + String(timeValue) + " + keepAliveTimeout: " + String(timeValue + keepAliveTimeout));
  }
}

void InnerLoop() {
  soundBarPowerPinState = digitalRead(soundBarPowerPin);
  if (soundBarPowerSwitch) {
    if (soundBarPowerPinState == LOW) {
      Serial.println("Power off sound bar");
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F08F7U, IR_CODE_NUM_BITS);
      for (int i = 0; i < 150; i++) {
        delay(10);
        IrSender.sendNEC(0xFFFFFFFF, 0);
      }
      soundBarPowerSwitch = false;
      delay(250);
    }
  } else {
    if (soundBarPowerPinState == LOW) {
      Serial.println("Power on sound bar");
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F08F7U, IR_CODE_NUM_BITS);
      soundBarPowerSwitch = true;
      delay(250);
    }
  }

  volumeValue = analogRead(potentiometerPin);
  volumeLevel = volumeValue / 64;
  if (volumeFirstRead) {
    volumeTracker = volumeLevel;
    volumeFirstRead = false;
  }

  if (volumeLevel != volumeTracker) {
    if (volumeLevel < volumeTracker) {
      Serial.print("Volume down: ");
      Serial.print(volumeValue);
      Serial.print("  ");
      Serial.println(volumeLevel);
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F10EFU, IR_CODE_NUM_BITS);
      volumeTracker = volumeLevel;
    } else {
      Serial.print("Volume up: ");
      Serial.print(volumeValue);
      Serial.print("  ");
      Serial.println(volumeLevel);
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F8877U, IR_CODE_NUM_BITS);
      volumeTracker = volumeLevel;
    }
    delay(250);
  }

  volOvPinState = digitalRead(volOvPin);
  if (volOvPinState == LOW) {
    if (volumeLevel < 7) {
      Serial.println("Volume down (override)");
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F10EFU, IR_CODE_NUM_BITS);
    } else {
      Serial.println("Volume up (override)");
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F8877U, IR_CODE_NUM_BITS);
    }
    delay(250);
  }

  opticalPinState = digitalRead(opticalPin);
  if (inputSourceSwitch) {
    if (opticalPinState == LOW) {
      Serial.println("Bluetooth");
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F52ADU, IR_CODE_NUM_BITS);
      inputSourceSwitch = false;
      delay(250);
    }
  } else {
    if (opticalPinState == LOW) {
      Serial.println("Optical");
      digitalWrite(redLedPin, LOW);
      IrSender.sendNEC(0x807F926DU, IR_CODE_NUM_BITS);
      inputSourceSwitch = true;
      delay(250);
    }
  }

  tvPowerPinState = digitalRead(tvPowerPin);
  if (tvPowerSwitch) {
    if (tvPowerPinState == LOW) {
      Serial.println("Power off tv");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSAMSUNG(0xE0E040BF, IR_CODE_NUM_BITS);
      tvPowerSwitch = false;
      delay(250);
    }
  } else {
    if (tvPowerPinState == LOW) {
      Serial.println("Power on tv");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSAMSUNG(0xE0E040BF, IR_CODE_NUM_BITS);
      tvPowerSwitch = true;
      delay(250);
    }
  }

  xPosition = analogRead(joystickRxPin);
  yPosition = analogRead(joystickRyPin);
  joystickPinState = digitalRead(joystickButtonPin);
  mapX = map(xPosition, 0, 1023, -512, 512);
  mapY = map(yPosition, 0, 1023, -512, 512);
  scrollPinState = digitalRead(scrollPin);
  backButtonPinState = digitalRead(backButtonPin);

  if ((backButtonPinState == 0 || joystickPinState == 0 || mapX > joystickThreshold || mapX < -joystickThreshold || mapY > joystickThreshold || mapY < -joystickThreshold) && !esp8266Init) {
    if (backButtonPinState == 0) {
      Serial.println("home");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSamsung(0x707, 0x79, 0, false);
    } else if (joystickPinState == 0) {
      Serial.println("enter");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSamsung(0x707, 0x68, 0, false);
    } else if (mapX > joystickThreshold) {
      Serial.println("left");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSamsung(0x707, 0x65, 0, false);
    } else if (mapX < -joystickThreshold) {
      Serial.println("right");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSamsung(0x707, 0x62, 0, false);
    } else if (mapY > joystickThreshold) {
      Serial.println("up");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSamsung(0x707, 0x60, 0, false);
    } else if (mapY < -joystickThreshold) {
      Serial.println("down");
      digitalWrite(redLedPin, LOW);
      IrSender.sendSamsung(0x707, 0x61, 0, false);
    }
    delay(250);
  }

  if ((joystickPinState == 0 || scrollPinState == 0 || mapX > joystickThreshold || mapX < -joystickThreshold || mapY > joystickThreshold || mapY < -joystickThreshold) && clientConnected) {
    joystickOutput = String(mapX) + "," + String(mapY) + "," + String(joystickPinState) + "," + String(scrollPinState) + "\r\n";
    joystickSendLength = "AT+CIPSEND=0," + String(joystickOutput.length()) + "\r\n";
    TcpDataOut(joystickSendLength, 10);
    TcpDataOut(joystickOutput, 100);
    Serial.print(joystickOutput);
    digitalWrite(blueLedPin, LOW);
  }

  if (scrollPinState == 0 && !esp8266Init) {
    esp8266.begin(9600);
    Serial.println("Starting esp8266...");
    InitializeEsp8266();
    esp8266Init = true;
    Serial.println("Esp8266 ready");
  }

  if (esp8266Init) {
    TcpDataIn(50);
  }
  digitalWrite(redLedPin, HIGH);
  if (clientConnected) {
    digitalWrite(blueLedPin, HIGH);
  }
}

void InitializeEsp8266() {
  FlashBlueLed();
  TcpDataOut("AT+RST\r\n", 2100);
  FlashBlueLed();
  TcpDataOut("AT+CWMODE=1\r\n", 201);
  FlashBlueLed();
  dataOutResult = TcpDataOut("AT+CIFSR\r\n", 201);

  if (dataOutResult.indexOf("0.0") > 0) {
    Serial.println("Invalid IP");
    dataOutResult = TcpDataOut("AT+CWJAP=\"***REMOVED***\",\"***REMOVED***\"\r\n", 2100); //3200
    while (!esp8266.find("OK")) {
    }
    if (dataOutResult.indexOf("0.0") > 0) {
      Serial.println("Invalid IP after AT+CWJAP");
      ResetEsp8266();
      return;
    }
    Serial.println("Connected to wifi");
    TcpDataOut("AT+CIFSR\r\n", 201);
  }

  FlashBlueLed();
  TcpDataOut("AT+CIPMUX=1\r\n", 201); //enable multiple connections
  FlashBlueLed();
  TcpDataOut("AT+CIPSERVER=1,3000\r\n", 201);
  FlashBlueLed();
}

void ResetEsp8266() {
  BlinkBlueLed();
  Serial.println("Restarting esp8266...");
  InitializeEsp8266();
  Serial.println("Esp8266 ready");
  clientConnected = false;
}

void FlashBlueLed() {
  digitalWrite(blueLedPin, HIGH);
  delay(100);
  digitalWrite(blueLedPin, LOW);
}

void BlinkBlueLed() {
  digitalWrite(blueLedPin, LOW);
  delay(100);
  digitalWrite(blueLedPin, HIGH);
  delay(100);
  digitalWrite(blueLedPin, LOW);
  delay(100);
  digitalWrite(blueLedPin, HIGH);
  delay(100);
  digitalWrite(blueLedPin, LOW);
  delay(100);
  digitalWrite(blueLedPin, HIGH);
  delay(100);
  digitalWrite(blueLedPin, LOW);
  delay(100);
  digitalWrite(blueLedPin, HIGH);
  delay(100);
  digitalWrite(blueLedPin, LOW);
}

void TcpDataIn(const int timeout) {
  dataInResponse = "";
  long int time = millis();
  while ((time + timeout) > millis()) {
    while (esp8266.available()) {
      char c = esp8266.read();
      dataInResponse += c;
    }
  }
  if (dataInResponse.length() == 0) {
    if (!clientConnected) {
      FlashBlueLed();
    }
    return;
  }
  Serial.println("received: " + dataInResponse);

  if (dataInResponse.indexOf("zzzz") > 0 || dataInResponse.indexOf("zzz") > 0 ||
      dataInResponse.indexOf("zz") > 0 || dataInResponse.indexOf("z") > 0) {

    clientConnected = true;
    Serial.println("Client connected");
    tcpDataInOutput = "initack\r\n";
    tcpDataInSendLength = "AT+CIPSEND=0," + String(tcpDataInOutput.length()) + "\r\n";
    TcpDataOut(tcpDataInSendLength, 10);
    TcpDataOut(tcpDataInOutput, 100);
    clientConnected = true;
    return;
  }

  if (dataInResponse.indexOf("nlink") > 0) {
    Serial.println("Unlink detected");
    clientConnected = false;
    return;
  }
}

String TcpDataOut(String command, const int timeout) {
  dataOutResponse = "";
  esp8266.print(command);
  long int time = millis();
  while ((time + timeout) > millis()) {
    while (esp8266.available()) {
      char c = esp8266.read();
      dataOutResponse += c;
    }
  }

  if (dataOutResponse.indexOf("link is not") > 0) {
    Serial.println("Client disconnect tcp data out");
    clientConnected = false;
    return;
  }

  if (dataOutResponse.indexOf("Error") > 0) {
    Serial.println("Error in TcpDataOut");
    ResetEsp8266();
  }
  Serial.println(dataOutResponse);
  return dataOutResponse;
}

/*
  Serial.println(F("Enter number of signal to send (1 .. 20)"));
  long commandno = Serial.parseInt();
  joystickButtonPinitch (commandno) {
  case 1L:
    IrSender.sendNEC(0x807F08F7U, IR_CODE_NUM_BITS);
    break;
  case 2L:
    IrSender.sendNEC(0x807FE817U, IR_CODE_NUM_BITS);
    break;
  case 3L:
    IrSender.sendNEC(0x807F52ADU, IR_CODE_NUM_BITS);
    break;
  case 4L:
    IrSender.sendNEC(0x807F926DU, IR_CODE_NUM_BITS);
    break;
  case 5L:
    IrSender.sendNEC(0x807FE21DU, IR_CODE_NUM_BITS);
    break;
  case 6L:
    IrSender.sendNEC(0x807F50AFU, IR_CODE_NUM_BITS);
    break;
  case 7L:
    IrSender.sendNEC(0x807F8877U, IR_CODE_NUM_BITS);
    break;
  case 8L:
    IrSender.sendNEC(0x807F28D7U, IR_CODE_NUM_BITS);
    break;
  case 9L:
    IrSender.sendNEC(0x807F10EFU, IR_CODE_NUM_BITS);
    break;
  case 10L:
    IrSender.sendNEC(0x807F906FU, IR_CODE_NUM_BITS);
    break;
  case 11L:
    IrSender.sendNEC(0x807F7A85U, IR_CODE_NUM_BITS);
    break;
  case 12L:
    IrSender.sendNEC(0x807FC23DU, IR_CODE_NUM_BITS);
    break;
  case 13L:
    IrSender.sendNEC(0x807F02FDU, IR_CODE_NUM_BITS);
    break;
  case 14L:
    IrSender.sendNEC(0x807FC837U, IR_CODE_NUM_BITS);
    break;
  case 15L:
    IrSender.sendNEC(0x807FB24DU, IR_CODE_NUM_BITS);
    break;
  case 16L:
    IrSender.sendNEC(0x807F32CDU, IR_CODE_NUM_BITS);
    break;
  case 17L:
    IrSender.sendNEC(0x807FD22DU, IR_CODE_NUM_BITS);
    break;
  case 18L:
    IrSender.sendNEC(0x807F0AF5U, IR_CODE_NUM_BITS);
    break;
  case 19L:
    IrSender.sendNEC(0x807FF20DU, IR_CODE_NUM_BITS);
    break;
  case 20L:
    IrSender.sendNEC(0x807F728DU, IR_CODE_NUM_BITS);
    break;
  case 21L:
    IrSender.sendSAMSUNG(POWER, IR_CODE_NUM_BITS);
    break;
  case 22L:
    IrSender.sendSAMSUNG(VOLUME_UP, IR_CODE_NUM_BITS);
    break;
  case 23L:
    IrSender.sendSAMSUNG(VOLUME_DOWN, IR_CODE_NUM_BITS);
    break;
  default:
    Serial.println(F("Invalid number entered, try again"));
    break;
  }

  // --- SAMSUNG ---

  #define POWER 0xE0E040BF
  #define VOLUME_UP 0xE0E0E01F
  #define VOLUME_DOWN 0xE0E0D02F

  power

  04:47:29.791 -> Protocol=SAMSUNG Address=0x707 Command=0xE6 Raw-Data=0x19E60707 32 bits LSB first
  04:47:29.892 -> ERROR: Received address=0x707 != sent address=0xF1
  04:47:29.938 -> ERROR: Received command=0xE6 != sent command=0x76

  left
  04:44:29.282 -> Protocol=SAMSUNG Address=0x707 Command=0x62 Raw-Data=0x9D620707 32 bits LSB first
  04:44:29.382 -> ERROR: Received address=0x707 != sent address=0xF1
  04:44:29.429 -> ERROR: Received command=0x62 != sent command=0x76

  right

  04:44:38.743 -> Protocol=SAMSUNG Address=0x707 Command=0x65 Raw-Data=0x9A650707 32 bits LSB first
  04:44:38.787 -> ERROR: Received address=0x707 != sent address=0xF1
  04:44:38.870 -> ERROR: Received command=0x65 != sent command=0x76

  up
  04:45:41.307 -> Protocol=SAMSUNG Address=0x707 Command=0x60 Raw-Data=0x9F600707 32 bits LSB first
  04:45:41.407 -> ERROR: Received address=0x707 != sent address=0xF1
  04:45:41.454 -> ERROR: Received command=0x60 != sent command=0x76

  down
  04:45:48.893 -> Protocol=SAMSUNG Address=0x707 Command=0x61 Raw-Data=0x9E610707 32 bits LSB first
  04:45:48.940 -> ERROR: Received address=0x707 != sent address=0xF1
  04:45:48.994 -> ERROR: Received command=0x61 != sent command=0x76

  home

  04:46:03.027 -> Protocol=SAMSUNG Address=0x707 Command=0x79 Raw-Data=0x86790707 32 bits LSB first
  04:46:03.127 -> ERROR: Received address=0x707 != sent address=0xF1
  04:46:03.181 -> ERROR: Received command=0x79 != sent command=0x76

  ok

  04:46:13.325 -> Protocol=SAMSUNG Address=0x707 Command=0x68 Raw-Data=0x97680707 32 bits LSB first
  04:46:13.426 -> ERROR: Received address=0x707 != sent address=0xF1
  04:46:13.473 -> ERROR: Received command=0x68 != sent command=0x76

  back

  04:46:22.735 -> ERROR: Received command=0x58 != sent command=0x76
  04:46:23.993 -> Protocol=SAMSUNG Address=0x707 Command=0x58 Raw-Data=0xA7580707 32 bits LSB first
  04:46:24.093 -> ERROR: Received address=0x707 != sent address=0xF1
  04:46:24.139 -> ERROR: Received command=0x58 != sent command=0x76

*/

// Command #1: Power
// Protocol: nec1, Parameters: hex=247U D=1U param3=0U param4=0U F=16U

// Command #2: Mute
// Protocol: nec1, Parameters: hex=23U D=1U param3=0U param4=0U F=23U

// Command #3: BT
// Protocol: nec1, Parameters: hex=173U D=1U param3=0U param4=0U F=74U

// Command #4: Optical
// Protocol: nec1, Parameters: hex=109U D=1U param3=0U param4=0U F=73U

// Command #5: Line In
// Protocol: nec1, Parameters: hex=29U D=1U param3=0U param4=0U F=71U

// Command #6: USB
// Protocol: nec1, Parameters: hex=175U D=1U param3=0U param4=0U F=10U

// Command #7: up arrow
// Protocol: nec1, Parameters: hex=119U D=1U param3=0U param4=0U F=17U

// Command #8: right arrow
// Protocol: nec1, Parameters: hex=215U D=1U param3=0U param4=0U F=20U

// Command #9: down arrow
// Protocol: nec1, Parameters: hex=239U D=1U param3=0U param4=0U F=8U

// Command #10: left arrow
// Protocol: nec1, Parameters: hex=111U D=1U param3=0U param4=0U F=9U

// Command #11: Select
// Protocol: nec1, Parameters: hex=133U D=1U param3=0U param4=0U F=94U

// Command #12: General
// Protocol: nec1, Parameters: hex=61U D=1U param3=0U param4=0U F=67U

// Command #13: Voice
// Protocol: nec1, Parameters: hex=253U D=1U param3=0U param4=0U F=64U

// Command #14: Reset
// Protocol: nec1, Parameters: hex=55U D=1U param3=0U param4=0U F=19U

// Command #15: Bass
// Protocol: nec1, Parameters: hex=77U D=1U param3=0U param4=0U F=77U

// Command #16: Bass+
// Protocol: nec1, Parameters: hex=205U D=1U param3=0U param4=0U F=76U

// Command #17: Bass-
// Protocol: nec1, Parameters: hex=45U D=1U param3=0U param4=0U F=75U

// Command #18: Treble
// Protocol: nec1, Parameters: hex=245U D=1U param3=0U param4=0U F=80U

// Command #19: Treble+
// Protocol: nec1, Parameters: hex=13U D=1U param3=0U param4=0U F=79U

// Command #20: Treble-
// Protocol: nec1, Parameters: hex=141U D=1U param3=0U param4=0U F=78U
